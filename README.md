# Постановка задачи (вариант 4) #
## **Библиотека** ##

Сущности: Книги (регистрационный номер, количество страниц, год
издания, раздел - учебник, художественная общественно-политическая и
т.д. ), читатели (ФИО, домашний адрес, паспортные данные).

Процессы: Необходимо регистрировать дату, когда какой - либо читатель берет или
возвращает книгу

Выходные документы:

+ список читателей, которые держат на руках книги более месяца, с
перечислением названия книги и даты выдачи, упорядоченный
по датам выдачи, с указанием количества книг, которые должен
сдать каждый читатель;

+ для заданного читателя выдать список прочитанных им книг,
сортируя по датам получения.

# Лабораторная №1. Проектирование структуры БД #

##  ER-таблица ##

![alt text](image.png)

## Логическая модель ##
### *Описание сущностей и их атрибутов* ###
    Книги
        Регистрационный номер (PK, VARCHAR) - Уникальный идентификатор книги
        Количество страниц (INT) - Общее количество страниц в книге
        Год издания (INT) - Год, когда книга была издана
        Раздел (VARCHAR) - Раздел, к которому относится книга (учебник, художественная, общественно-политическая и т.д.)
        Название (VARCHAR) - Название книги

    Читатели
        ID читателя (PK, INT) - Уникальный идентификатор читателя
        Фамилия (VARCHAR) - Фамилия читателя
        Имя (VARCHAR) - Имя читателя
        Отчество (VARCHAR) - Отчество читателя (если есть)
        Домашний адрес (VARCHAR) - Адрес места проживания читателя
        Паспортные данные (TEXT) - Данные паспорта читателя

    Выдачи
        ID выдачи (PK, INT) - Уникальный идентификатор записи о выдаче книги
        ID читателя (FK, INT) - Ссылка на читателя, который берет книгу
        Регистрационный номер книги (FK, VARCHAR) - Ссылка на выданную книгу
        Дата выдачи (DATE) - Дата, когда книга была выдана
        Дата возврата (DATE) - Дата, когда книга была возвращена (может быть NULL, если книга еще не возвращена)
        Статус аренды (BOOL) - Статус аренды книги (TRUE - на руках, FALSE - возвращена)

### *Описание связей* ###

    Читатели и Выдачи
        Один читатель (1) может иметь множество выдач (N).

    Книги и Выдачи
        Одна книга (1) может быть выдана множеству читателей, но для каждой выдачи она привязана к одной книге (N).
        
## Физическая модель ##

    CREATE TABLE Книги 
        Регистрационный_номер VARCHAR PRIMARY KEY,
        Количество_страниц INT,
        Год_издания INT,
        Раздел VARCHAR,
        Название VARCHAR


    CREATE TABLE Читатели 
        ID_читателя INT PRIMARY KEY AUTO_INCREMENT,
        Фамилия VARCHAR,
        Имя VARCHAR,
        Отчество VARCHAR,
        Домашний_адрес VARCHAR,
        Паспортные_данные TEXT


    CREATE TABLE Выдачи 
        ID_выдачи INT PRIMARY KEY AUTO_INCREMENT,
        ID_читателя INT,
        Регистрационный_номер_книги VARCHAR,
        Дата_выдачи DATE,
        Дата_возврата DATE DEFAULT NULL,
        Статус_аренды BOOL,
        FOREIGN KEY (ID_читателя) REFERENCES Читатели(ID_читателя),
        FOREIGN KEY (Регистрационный_номер_книги) REFERENCES Книги (Регистрационный_номер)

# SQL DDL

## Таблицы ##


    Таблица книг
        CREATE TABLE Книги (
        id SERIAL PRIMARY KEY,
        регистрационный_номер VARCHAR(50) UNIQUE NOT NULL,
        количество_страниц INTEGER NOT NULL,
        год_издания INTEGER NOT NULL,
        раздел VARCHAR(100) NOT NULL,
        название VARCHAR(255) NOT NULL
    );

    Таблица читателей
    CREATE TABLE Читатели (
        id SERIAL PRIMARY KEY,
        фамилия VARCHAR(100) NOT NULL,
        имя VARCHAR(100) NOT NULL,
        отчество VARCHAR(100),
        домашний_адрес TEXT NOT NULL,
        паспортные_данные TEXT NOT NULL
    );

    Таблица выдачи книг
    CREATE TABLE Выдачи (
        id SERIAL PRIMARY KEY,
        читатель_id INTEGER NOT NULL,
        книга_id INTEGER NOT NULL,
        дата_выдачи DATE NOT NULL DEFAULT CURRENT_DATE,
        дата_возврата DATE,
        FOREIGN KEY (читатель_id) REFERENCES Читатели(id) ON DELETE CASCADE,
        FOREIGN KEY (книга_id) REFERENCES Книги(id) ON DELETE CASCADE,
        CHECK (дата_возврата IS NULL OR дата_возврата >= дата_выдачи)
    );

    Создание индексов для оптимизации запросов
    CREATE INDEX idx_выдачи_дата_возврата ON Выдачи(дата_возврата);
    CREATE INDEX idx_выдачи_дата_выдачи ON Выдачи(дата_выдачи);
    CREATE INDEX idx_выдачи_читатель ON Выдачи(читатель_id);
# Примеры запросов
## Поиск книг по разделу
    SELECT
        название as "Название книги",
        раздел as "Раздел",
        год_издания as "Год издания",
        количество_страниц as "Количество страниц"
    FROM Книги
    WHERE Книги.раздел IN ('Художественная литература', 'Фантастика', 'Приключения', 'Детектив')
    ORDER BY название;
## Книги на руках у читателей (текущие выдачи)
    SELECT
        CONCAT(Читатели.фамилия, ' ', Читатели.имя, ' ', COALESCE(Читатели.отчество, '')) as "ФИО читателя",
        Книги.название as "Название книги",
        Выдачи.дата_выдачи as "Дата выдачи",
        (CURRENT_DATE - Выдачи.дата_выдачи) as "Дней на руках"
    FROM Выдачи
    JOIN Читатели ON Выдачи.читатель_id = Читатели.id
    JOIN Книги ON Выдачи.книга_id = Книги.id
    WHERE Выдачи.дата_возврата IS NULL
    ORDER BY Выдачи.дата_выдачи;
## Статистика по прочитанным книгам для читателя
    SELECT
        Книги.название as "Название книги",
        Книги.раздел as "Раздел",
        Выдачи.дата_выдачи as "Дата получения",
        Выдачи.дата_возврата as "Дата возврата",
        (Выдачи.дата_возврата - Выдачи.дата_выдачи) as "Дней чтения"
    FROM Выдачи
    JOIN Книги ON Выдачи.книга_id = Книги.id
    WHERE Выдачи.читатель_id = 1
        AND Выдачи.дата_возврата IS NOT NULL
    ORDER BY Выдачи.дата_выдачи DESC;
## Самые популярные книги (по кол-во выдач)
    SELECT
        Книги.название as "Название книги",
        Книги.раздел as "Раздел",
        COUNT(Выдачи.id) as "Количество выдач"
    FROM Книги
    JOIN Выдачи ON Книги.id = Выдачи.книга_id
    GROUP BY Книги.id, Книги.название, Книги.раздел
    ORDER BY COUNT(Выдачи.id) DESC
    LIMIT 10;
# SQL-скрипт для заполнения таблиц данными
## Заполнение таблицы Читатели (4 читателя)
    INSERT INTO Читатели (фамилия, имя, отчество, домашний_адрес, паспортные_данные) VALUES
        ('Иванов', 'Иван', 'Иванович', 'г. Москва, ул. Ленина, д. 10, кв. 5', 'Серия 45 01 №123456 выдан ОВД Москвы 15.01.2020'),
        ('Петрова', 'Мария', 'Сергеевна', 'г. Санкт-Петербург, ул. Пушкина, д. 25, кв. 12', 'Серия 40 02 №654321 выдан ОВД СПб 20.03.2019'),
        ('Сидоров', 'Алексей', 'Петрович', 'г. Екатеринбург, пр. Ленина, д. 45, кв. 8', 'Серия 66 03 №789012 выдан ОВД Екатеринбурга 10.05.2021'),
        ('Козлова', 'Анна', 'Владимировна', 'г. Казань, ул. Баумана, д. 15, кв. 3', 'Серия 16 04 №345678 выдан ОВД Казани 05.11.2022');

## Заполнение таблицы Книги (6 книг разных разделов)
    INSERT INTO Книги (регистрационный_номер, количество_страниц, год_издания, раздел, название) VALUES
    ('LIB-2023-001', 450, 2023, 'Художественная литература', 'Война и мир'),
    ('LIB-2020-002', 320, 2020, 'Художественная литература', 'Преступление и наказание'),
    ('LIB-2021-003', 280, 2021, 'Научно-популярная', 'Краткая история времени'),
    ('LIB-2019-004', 150, 2019, 'Детектив', 'Убийство в Восточном экспрессе'),
    ('LIB-2022-005', 600, 2022, 'Учебная литература', 'Основы программирования на Python'),
    ('LIB-2023-006', 380, 2023, 'Фантастика', 'Дюна');

## Заполнение таблицы Выдачи (8 записей о выдаче книг)
    INSERT INTO Выдачи (читатель_id, книга_id, дата_выдачи, дата_возврата) VALUES
    Книги на руках (не возвращены)
    (1, 1, '2024-03-01', NULL),  -- Иванов взял "Войну и мир"
    (2, 3, '2024-03-15', NULL),  -- Петрова взяла "Краткую историю времени"
    (3, 6, '2024-03-20', NULL),  -- Сидоров взял "Дюну"

    Возвращенные книги
    (1, 2, '2024-01-10', '2024-02-01'),  -- Иванов вернул "Преступление и наказание"
    (2, 4, '2024-02-05', '2024-02-20'),  -- Петрова вернула "Убийство в Восточном экспрессе"
    (3, 5, '2024-01-15', '2024-01-30'),  -- Сидоров вернул "Основы программирования"
    (4, 1, '2024-02-10', '2024-03-01'),  -- Козлова вернула "Войну и мир"
    (4, 3, '2024-01-20', '2024-02-10');  -- Козлова вернула "Краткую историю времени"
# Проверочные запросы после заполнения:
## Проверка количества записей
    SELECT 'Читатели' as Таблица, COUNT(*) as Количество FROM Читатели
    UNION ALL
    SELECT 'Книги', COUNT(*) FROM Книги
    UNION ALL
    SELECT 'Выдачи', COUNT(*) FROM Выдачи;

## Посмотреть все читатели
    SELECT * FROM Читатели;

## Посмотреть все книги
    SELECT * FROM Книги ORDER BY раздел, название;

## Посмотреть текущие выдачи (книги на руках)
    SELECT
        CONCAT(Читатели.фамилия, ' ', Читатели.имя) as Читатель,
        Книги.название as Книга,
        Выдачи.дата_выдачи,
        (CURRENT_DATE - Выдачи.дата_выдачи) as Дней_на_руках
    FROM Выдачи
    JOIN Читатели ON Выдачи.читатель_id = Читатели.id
    JOIN Книги ON Выдачи.книга_id = Книги.id
    WHERE Выдачи.дата_возврата IS NULL;


## Транскрипт ИИ ##
Отличная работа по проектированию базы данных для библиотеки! Структура логична и хорошо продумана. Позвольте я предложу несколько дополнений и уточнений, которые сделают модель более надежной и эффективной, а также подготовлю запросы для формирования требуемых выходных документов.
Анализ и рекомендации по вашей модели

    Первичный ключ для Книги: Использование VARCHAR для первичного ключа возможно, но может быть неэффективно с точки производительности и использования индексов, особенно если это строковое значение с переменной длиной. Лучше использовать числовой INT AUTO_INCREMENT (или SERIAL в PostgreSQL). Регистрационный_номер тогда можно оставить как уникальное поле.

    Дата возврата и Статус аренды: Поле Статус_аренды является избыточным. Состояние книги (на руках или возвращена) можно однозначно определить по полю Дата_возврата: если NULL — книга на руках, если есть дата — возвращена. Это исключает возможность противоречия данных.

    Целостность данных: Можно добавить CHECK ограничения, чтобы Год_издания был правдоподобным, а Дата_возврата не могла быть раньше Даты_выдачи.

    Индексы: Для ускорения запросов, особенно для отчетов, которые фильтруют по датам, нужны соответствующие индексы.

Улучшенная физическая модель (с учетом рекомендаций)
sql

    CREATE TABLE Книги (
        ID_книги INT PRIMARY KEY AUTO_INCREMENT,      -- Новый числовой PK
        Регистрационный_номер VARCHAR UNIQUE NOT NULL, -- Остается как уникальный идентификатор
        Количество_страниц INT NOT NULL CHECK (Количество_страниц > 0),
        Год_издания INT NOT NULL CHECK (Год_издания > 1500 AND Год_издания <= EXTRACT(YEAR FROM CURRENT_DATE)),
        Раздел VARCHAR NOT NULL,
        Название VARCHAR NOT NULL
    );

    CREATE TABLE Читатели (
        ID_читателя INT PRIMARY KEY AUTO_INCREMENT,
        Фамилия VARCHAR NOT NULL,
        Имя VARCHAR NOT NULL,
        Отчество VARCHAR,
        Домашний_адрес TEXT NOT NULL,
        Паспортные_данные TEXT NOT NULL
    );

    CREATE TABLE Выдачи (
        ID_выдачи INT PRIMARY KEY AUTO_INCREMENT,
        ID_читателя INT NOT NULL,
        ID_книги INT NOT NULL, -- Ссылаемся на новый ID_книги
        Дата_выдачи DATE NOT NULL DEFAULT (CURRENT_DATE),
        Дата_возврата DATE NULL, -- NULL означает, что книга еще на руках
        -- Убрано избыточное поле Статус_аренды
        FOREIGN KEY (ID_читателя) REFERENCES Читатели(ID_читателя) ON DELETE CASCADE,
        FOREIGN KEY (ID_книги) REFERENCES Книги(ID_книги) ON DELETE CASCADE,
        CHECK (Дата_возврата IS NULL OR Дата_возврата >= Дата_выдачи) -- Проверка логики дат
    );

____
    Создание индексов для ускорения поиска
    CREATE INDEX idx_выдачи_дата_возврата ON Выдачи (Дата_возврата);
    CREATE INDEX idx_выдачи_дата_выдачи ON Выдачи (Дата_выдачи);
    CREATE INDEX idx_выдачи_читатель ON Выдачи (ID_читателя);

Запросы для выходных документов

Теперь, на основе улучшенной модели, напишем запросы для требуемых отчетов.
1. Список читателей с просроченными книгами (> 1 месяца)

Этот запрос:

    Находит книги, которые еще не возвращены (Дата_возврата IS NULL) и выданы более 30 дней назад.

    Группирует по читателям, подсчитывая количество книг у каждого.

    Сортирует по дате выдачи (старые — сначала).

sql

    SELECT
        CONCAT(Ч.Фамилия, ' ', Ч.Имя, ' ', COALESCE(Ч.Отчество, '')) AS ФИО_читателя,
        COUNT(*) AS Количество_книг_на_руках,
        К.Название AS Название_книги,
        В.Дата_выдачи
    FROM
        Выдачи В
        JOIN Читатели Ч ON В.ID_читателя = Ч.ID_читателя
        JOIN Книги К ON В.ID_книги = К.ID_книги
    WHERE
        В.Дата_возврата IS NULL -- Книга не возвращена
        AND В.Дата_выдачи < CURRENT_DATE - INTERVAL 1 MONTH -- Выдана более месяца назад
    GROUP BY
        В.ID_читателя, В.ID_выдачи
    ORDER BY
        В.Дата_выдачи ASC; -- Сортировка по дате выдачи (сначала старые)

2. Список прочитанных книг для заданного читателя

Этот запрос:

    Выбирает все выдачи для конкретного читателя (например, с ID_читателя = 5), которые уже возвращены.

    Сортирует результат по дате получения книги (по умолчанию ASC — от старых к новым, можно изменить на DESC).

sql

    SELECT
        К.Название AS Название_книги,
        К.Раздел,
        В.Дата_выдачи,
        В.Дата_возврата
    FROM
        Выдачи В
        JOIN Книги К ON В.ID_книги = К.ID_книги
    WHERE
        В.ID_читателя = 5 -- Подставьте нужный ID читателя
        AND В.Дата_возврата IS NOT NULL -- Книга уже возвращена (т.е. прочитана)
    ORDER BY
        В.Дата_выдачи ASC; -- Сортировка по дате получения

Итог

Ваша первоначальная модель была вполне рабочей. Внесенные предложения направлены на повышение ее надежности, производительности и соответствия принципам нормализации. Запросы решают поставленные в задаче задачи и готовы к использованию.